<?php

namespace WPDiscourse\DiscourseWebhook;

use \WPDiscourse\Utilities\Utilities as DiscourseUtilities;

class DiscourseWebhook {

	protected $options;

	public function __construct() {
		add_action( 'init', array( $this, 'setup_options' ) );
		add_action( 'rest_api_init', array( $this, 'initialize_comment_route' ) );
	}

	public function setup_options() {
		$this->options                        = DiscourseUtilities::get_options();
	}

	public function initialize_comment_route() {
		if ( ! empty( $this->options['use-discourse-webhook'] ) && 1 === intval( $this->options['use-discourse-webhook'] ) ) {
			register_rest_route( 'wp-discourse/v1', 'update-topic-content', array(
				array(
					'methods'  => \WP_REST_Server::CREATABLE,
					'callback' => array( $this, 'update_topic_content' ),
				),
			) );
		}
	}

	public function update_topic_content( $data ) {
		$data = $this->verify_discourse_request( $data );

		if ( is_wp_error( $data ) ) {

			return new \WP_Error( 'discourse_webhook_error', __( 'Unable to process Discourse webhook.', 'wp-discourse' ) );
		}


		$json = $data->get_json_params();
		write_log( 'json data', $json );
		if ( ! empty( $json['post'] ) && ! empty( $json['post']['embed_url'] ) ) {
			$post_data = $json['post'];
			$topic_id  = $post_data['topic_id'];
			$post_number = $post_data['post_number'] - 1;

			if ( is_multisite() ) {
				// Todo: this is assuming a subdomain URL, make work for subdirectory install (if (defined( 'SUBDOMAIN_INSTALL'))...)
				$embed_url = parse_url( $post_data['embed_url'], PHP_URL_HOST );
				$blog_id   = get_blog_id_from_url( $embed_url );
				switch_to_blog( $blog_id );
				$post_id = DiscourseUtilities::get_post_id_by_topic_id( $topic_id );

				if ( $post_id ) {
					$current_comment_count = get_post_meta( $post_id, 'discourse_comments_count', true );
					if ( $current_comment_count && $current_comment_count < $post_number - 1 ) {
						update_post_meta( $post_id, 'discourse_comments_count', $post_number - 1 );
					}

					update_post_meta( $post_id, 'wpdc_sync_post_comments', 1 );
				}
				restore_current_blog();
			} else {
				$post_id = DiscourseUtilities::get_post_id_by_topic_id( $topic_id );
				if ( $post_id ) {
					$current_comment_count = get_post_meta( $post_id, 'discourse_comments_count', true );
					if ( $current_comment_count && $current_comment_count < $post_number - 1 ) {
						update_post_meta( $post_id, 'discourse_comments_count', $post_number - 1 );
					}

					update_post_meta( $post_id, 'wpdc_sync_post_comments', 1 );
				}
			}
		}
	}

	/**
	 * Verify that the request originated from a Discourse webhook and the the secret keys match.
	 *
	 * @param \WP_REST_Request $data
	 *
	 * @return \WP_Error|\WP_REST_Request
	 */
	protected function verify_discourse_request( $data ) {
		// The X-Discourse-Event-Signature consists of 'sha256=' . hamc of raw payload.
		// It is generated by computing `hash_hmac( 'sha256', $payload, $secret )`
		if ( $sig = substr( $data->get_header( 'X-Discourse-Event-Signature' ), 7 ) ) {
			$payload = $data->get_body();
			// Key used for verifying the request - a matching key needs to be set on the Discourse webhook.
			$secret = ! empty( $this->options['webhook-secret'] ) ? $this->options['webhook-secret'] : '';

			if ( ! $secret ) {
				return new \WP_Error( 'discourse_webhook_configuration_error', 'The webhook secret key has not been set.' );
			}

			if ( $sig === hash_hmac( 'sha256', $payload, $secret ) ) {

				return $data;
			} else {

				return new \WP_Error( 'discourse_webhook_authentication_error', 'Discourse Webhook Request Error: signatures did not match.' );
			}
		}

		return new \WP_Error( 'discourse_webhook_authentication_error', 'Discourse Webhook Request Error: the X-Discourse-Event-Signature was not set for the request.' );
	}
}